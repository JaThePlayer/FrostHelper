using System.Runtime.InteropServices;

namespace FrostHelper;

[CustomEntity("FrostHelper/RainbowTilesetController")]
[Tracked]
public class RainbowTilesetController : Entity {
    #region Hooks
    private static bool _loadedHooks;

    public static void LoadHooksIfNeeded() {
        if (_loadedHooks)
            return;
        _loadedHooks = true;

        IL.Monocle.TileGrid.RenderAt += TileGrid_RenderAt;
        On.Celeste.Debris.Init_Vector2_char_bool += DebrisOnInit_Vector2_char_bool;
    }

    [OnUnload]
    public static void Unload() {
        if (!_loadedHooks)
            return;
        _loadedHooks = false;

        IL.Monocle.TileGrid.RenderAt -= TileGrid_RenderAt;
        On.Celeste.Debris.Init_Vector2_char_bool -= DebrisOnInit_Vector2_char_bool;
    }

    private static Debris DebrisOnInit_Vector2_char_bool(On.Celeste.Debris.orig_Init_Vector2_char_bool orig, Debris self, Vector2 pos, char tileset, bool playsound) {
        var d = orig(self, pos, tileset, playsound);
        var c = GetController();
        if (c is { }) {
            if (c._allDebris || c._debris.Contains(tileset)) {
                d.PostUpdate += static (entity) => {
                    var debris = (Debris)entity;
                    debris.image.Color =
                        // Todo: if needed, impl Mode.LerpedToGray here, as this is vanilla behavior:
                        //Color.Lerp(ColorHelper.GetHue(self.Scene, self.image.RenderPosition), Color.Gray, self.fadeLerp) * self.alpha;
                        ColorHelper.GetHue(debris.Scene, debris.image.RenderPosition) * debris.alpha;
                };
            }
        }
        
        return d;
    }

    private static byte GetFirstLocalId(ILCursor cursor, string typeName) {
        return (byte) cursor.Body.Variables.First(v => v.VariableType.Name.Contains(typeName)).Index;
    }

    private static void TileGrid_RenderAt(ILContext il) {
        ILCursor cursor = new ILCursor(il);

        var positionId = GetFirstLocalId(cursor, "Vector2");
        var mTextureId = GetFirstLocalId(cursor, "MTexture");

        VariableDefinition controllerId = new VariableDefinition(il.Import(typeof(RainbowTilesetController)));
        il.Body.Variables.Add(controllerId);

        cursor.EmitCall(GetController);
        cursor.Emit(OpCodes.Stloc, controllerId);

        if (cursor.TryGotoNext(MoveType.After, instr => instr.MatchCallvirt<SpriteBatch>("Draw"))) {
            cursor.Index--; // go back to the last step, which is when the color is loaded
            cursor.Emit(OpCodes.Ldloc_S, positionId); // pos
            cursor.Emit(OpCodes.Ldloc_S, mTextureId); // mTexture
            cursor.Emit(OpCodes.Ldarg_0); // this
            cursor.Emit(OpCodes.Ldloc, controllerId);
            cursor.EmitCall(GetColor);
        }
    }

    private static RainbowTilesetController? GetController() {
        return Engine.Scene.Tracker.SafeGetEntity<RainbowTilesetController>();
    }

    private static Color GetColor(Color col, Vector2 position, MTexture texture, TileGrid self, RainbowTilesetController? controller) {
        if (controller is { } && ContainsTexture(CollectionsMarshal.AsSpan(controller._tilesetTextures), texture.Parent)) {
            return ColorHelper.GetHue(Engine.Scene, position) * self.Alpha;
        }

        return col;
    }

    internal static bool ContainsTexture(Span<MTexture?> arr, MTexture check) {
        for (int i = 0; i < arr.Length; i++) {
            //if (ReferenceEquals(arr[i], check))
            // SpeedrunTool's savestates will clone the tilegrid, desyncing the MTexture instances
            // from those generated by the autotiler
            // TODO:(Perf) Use string comparison only if savestates were used?
            if (arr[i]?.AtlasPath == check.AtlasPath)
                return true;
        }
        return false;
    }
    #endregion

    // Nullable because missing textures can result in nulls here
    private List<MTexture?> _tilesetTextures;
    private HashSet<char> _debris;
    private bool _allDebris;

    internal RainbowTilesetController(params List<MTexture?> textures) {
        LoadHooksIfNeeded();
        
        _tilesetTextures = textures;
        _debris = [];
        _allDebris = false;
    }

    public RainbowTilesetController(EntityData data, Vector2 offset) : base(data.Position + offset) {
        LoadHooksIfNeeded();

        bool bg = data.Bool("bg", false);
        var all = data.Attr("tilesets") == "*";
        var autotiler = bg ? GFX.BGAutotiler : GFX.FGAutotiler;
        var includeDebris = data.Bool("includeDebris", false);
        Tag = Tags.Persistent;

        _allDebris = all && includeDebris;
        
        if (!all) {
            var tilesetIDs = FrostModule.GetCharArrayFromCommaSeparatedList(data.Attr("tilesets"));
            
            _debris = includeDebris ? new HashSet<char>(tilesetIDs) : [];

            _tilesetTextures = new(tilesetIDs.Length);
            for (int i = 0; i < _tilesetTextures.Capacity; i++) {
                _tilesetTextures.Add(autotiler.GenerateMap(new VirtualMap<char>(new[,] { { tilesetIDs[i] } }), true).TileGrid.Tiles[0, 0].Parent);
            }
        } else {
            var autotilerLookupKeys = autotiler.lookup;
            _tilesetTextures = new(autotilerLookupKeys.Count);
            var enumerator = autotilerLookupKeys.GetEnumerator();
            for (int i = 0; i < _tilesetTextures.Capacity; i++) {
                enumerator.MoveNext();
                _tilesetTextures.Add(autotiler.GenerateMap(new VirtualMap<char>(new[,] { { enumerator.Current.Key } }), true).TileGrid.Tiles[0, 0].Parent);
            }

            _debris = [];
        }
    }

    public override void Awake(Scene scene) {
        base.Awake(scene);
        var controllers = Scene.Tracker.SafeGetEntities<RainbowTilesetController>();
        if (controllers.Count > 1) {
            var first = controllers.First(c => c.Scene == scene) as RainbowTilesetController;
            if (first != this) {
                first!._tilesetTextures = first._tilesetTextures.Union(_tilesetTextures).ToList();
                first._debris.UnionWith(_debris);
                first._allDebris |= _allDebris;
                RemoveSelf();
            }
        }
    }

    internal static void RainbowifyTexture(Scene scene, MTexture texture) {
        // Check if its already rainbowified
        if (ControllerHelper<RainbowTilesetController>.FindFirst(scene,
                c => ContainsTexture(CollectionsMarshal.AsSpan(c._tilesetTextures), texture)) is { }) {
            return;
        }
        
        var c = ControllerHelper<RainbowTilesetController>.AddToSceneIfNeeded(scene,
            c => true,
            () => new RainbowTilesetController(texture));

        if (!ContainsTexture(CollectionsMarshal.AsSpan(c._tilesetTextures), texture)) {
            c._tilesetTextures.Add(texture);
        }
    }
}
