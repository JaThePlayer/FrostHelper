using FrostHelper.Helpers;
using FrostHelper.SessionExpressions;
using System.Diagnostics.CodeAnalysis;

namespace FrostHelper.API;

// [ModExportName("FrostHelper")] - defined in API.cs
public static partial class API {
    /// <summary>
    /// Creates an object which can evaluate a Session Expression.
    /// The returned object can be passed to <see cref="GetSessionExpressionValue"/>
    /// Refer to https://github.com/JaThePlayer/FrostHelper/wiki/Session-Expressions
    /// </summary>
    public static bool TryCreateSessionExpression(string str, [NotNullWhen(true)] out object? expression) {
        return TryCreateSessionExpression(str, ExpressionContext.Default, out expression);
    }
    
    /// <summary>
    /// Creates an object which can evaluate a Session Expression, using the given Session Expression Context.
    /// The context object should be generated by <see cref="CreateSessionExpressionContext"/>.
    /// The returned object can be passed to <see cref="GetSessionExpressionValue"/>
    /// Refer to https://github.com/JaThePlayer/FrostHelper/wiki/Session-Expressions
    /// </summary>
    public static bool TryCreateSessionExpression(string str, object context, [NotNullWhen(true)] out object? expression) {
        if (ConditionHelper.TryCreate(str, AssertContext(context), out var expr)) {
            expression = expr;
            return true;
        }

        expression = null;
        return false;
    }

    /// <summary>
    /// Returns the current value of a Session Expression.
    /// The object passed as the 1st argument needs to be created via <see cref="TryCreateSessionExpression"/>
    /// </summary>
    public static object GetSessionExpressionValue(object expression, Session session)
        => AssertExpression(expression).Get(session, userdata: null);
    
    /// <summary>
    /// Returns the current value of a Session Expression with the given userdata, which can be any arbitrary object,
    /// passed to custom commands defined by the Session Expression Context used when creating the Session Expression.
    /// The object passed as the 1st argument needs to be created via <see cref="TryCreateSessionExpression"/>
    /// </summary>
    public static object GetSessionExpressionValue(object expression, Session session, object? userdata)
        => AssertExpression(expression).Get(session, userdata);
    
    /// <summary>
    /// Returns the type that the given session expression will return, or typeof(object) if that's unknown.
    /// The object passed as the 1st argument needs to be created via <see cref="TryCreateSessionExpression"/>
    /// </summary>
    public static Type GetSessionExpressionReturnedType(object expression) {
        var expr = AssertExpression(expression);

        return expr.ReturnType ?? typeof(object);
    }
    
    /// <summary>
    /// Returns the current value of a Session Expression as an integer, coercing it if needed.
    /// The object passed as the 1st argument needs to be created via <see cref="TryCreateSessionExpression"/>
    /// </summary>
    public static int GetIntSessionExpressionValue(object expression, Session session)
        => AssertExpression(expression).GetInt(session, userdata: null);
    public static int GetIntSessionExpressionValue(object expression, Session session, object? userdata)
        => AssertExpression(expression).GetInt(session, userdata);
    
    /// <summary>
    /// Returns the current value of a Session Expression as a float, coercing it if needed.
    /// The object passed as the 1st argument needs to be created via <see cref="TryCreateSessionExpression"/>
    /// </summary>
    public static float GetFloatSessionExpressionValue(object expression, Session session)
        => AssertExpression(expression).GetFloat(session, userdata: null);
    public static float GetFloatSessionExpressionValue(object expression, Session session, object? userdata)
        => AssertExpression(expression).GetFloat(session, userdata);
    
    /// <summary>
    /// Returns the current value of a Session Expression as a boolean, coercing it if needed.
    /// The object passed as the 1st argument needs to be created via <see cref="TryCreateSessionExpression"/>
    /// </summary>
    public static bool GetBoolSessionExpressionValue(object expression, Session session)
        => AssertExpression(expression).Check(session);
    public static bool GetBoolSessionExpressionValue(object expression, Session session, object? userdata)
        => AssertExpression(expression).Check(session, userdata);

    /// <summary>
    /// Registers a simple Session Expression command, which will be accessible via $modName.cmdName in Session Expressions.
    /// </summary>
    /// <param name="modName">Name of the mod which registers this command. Will be used to prefix the command name.</param>
    /// <param name="cmdName">Name of the command</param>
    /// <param name="func">Function called each time the command needs to be evaluated</param>
    public static void RegisterSimpleSessionExpressionCommand(string modName, string cmdName, Func<Session, object> func) {
        SimpleCommands.RegisterSimpleCommand(modName, cmdName, (session, userdata) => func(session));
    }

    /// <summary>
    /// Registers a Session Expression function, which will be accessible via $modName.cmdName in Session Expressions.
    /// </summary>
    /// <param name="modName">Name of the mod which registers this command. Will be used to prefix the command name.</param>
    /// <param name="cmdName">Name of the command</param>
    /// <param name="func">Function called each time the function needs to be evaluated.
    /// 2nd argument contains a list of the values of all arguments to the function.
    /// </param>
    public static void RegisterFunctionSessionExpressionCommand(string modName, string cmdName, Func<Session, IReadOnlyList<object>, object> func) {
        FunctionCommands.Register(modName, cmdName, (session, userdata, args) => func(session, args));
    }
    
    /// <summary>
    /// Creates a Session Expression Context object, which can be passed to <see cref="TryCreateSessionExpression(string,object,out object?)"/>
    /// This allows you to register custom commands for specific entities.
    /// A context should be created once, and reused as much as possible.
    /// <br />
    /// Do not capture entity instances into the Func objects, instead pass a `userdata` object when calling GetSessionExpressionValue,
    /// which will be passed as the 2nd argument your functions.
    /// <br />
    /// Dictionary keys are names under which the commands will be available. For example, if your key is 'coolValue',
    /// then it will be accessed as `$coolValue` in Session Expressions created using this context.
    /// </summary>
    public static object CreateSessionExpressionContext(
        Dictionary<string, Func<Session, object? /* userdata */, object>>? simpleCommands,
        Dictionary<string, Func<Session, object? /* userdata */, IReadOnlyList<object>, object>>? functionCommands) {
        
        return new ExpressionContext(
            (simpleCommands ?? []).ToDictionary(kv => kv.Key, kv => SimpleCommands.CreateCommandFromModFunc(kv.Value)),
            (functionCommands ?? []).ToDictionary(kv => kv.Key, kv => FunctionCommands.CreateFactoryForCustomCommand(kv.Value)));
    }

    // NON-API!
    private static ConditionHelper.Condition AssertExpression(object expression) {
        if (expression is not ConditionHelper.Condition expr) {
            throw new ArgumentException($"Object '{expression}' is not of type {nameof(ConditionHelper.Condition)}!");
        }

        return expr;
    }
    
    // NON-API!
    private static ExpressionContext AssertContext(object ctx) {
        if (ctx is not ExpressionContext expr) {
            throw new ArgumentException($"Object '{ctx}' is not of type {nameof(ExpressionContext)}!");
        }

        return expr;
    }
}